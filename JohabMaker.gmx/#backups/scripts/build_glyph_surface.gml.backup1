// 2018-12-21 03:24:10
#define build_glyph_surface
///build_glyph_surface(index)
/*
    Updates glyph surface from glyph index for use in font texture building
*/

// var
#args index
    
if (index < 0)
    return -1;

// Build character to draw
var data = charData[| index];
var glyphX = index % global.hangulFontRows, glyphY = index div global.hangulFontRows, char = "";

if (data[@ CHAR.SAMPLE] != "")
{
    char = data[@ CHAR.SAMPLE];
}
else
{
    switch (glyphY)
    {
        case 0: // Choseong beol 1
            char = chr($AC00 + ((glyphX * 21) + 0) * 28 + 16);
            break;
        
        case 1: // Choseong beol 2
            char = chr($AC00 + ((glyphX * 21) + 8) * 28 + 16);
            break;
            
        case 2: // Jungseong
            char = chr($AC00 + glyphX * 28 + 16);
            break;
        
        case 3: // Jongseong beol 1
            char = chr($AC00 + glyphX);
            break;
        
        case 4: // Choseong beol 2
            char = chr($AC00 + ((1 * 21) + 8) * 28 + glyphX);
            break;
            
        case 5: // Compat. Jamo
        case 6:
            var _off = $3130 + (index - gridWid * 5);
            
            if (_off >= $3130 && _off <= $3163)
                char = chr(_off);
            break;
            
        default: // ASCII
            char = chr(index - gridWid * 7);
    }
}


// clear surface
if (surface_exists(glyphSurf))
    surface_resize(glyphSurf, charWid, charHei);
else
    glyphSurf = surface_create(charWid, charHei);
    
surface_resize(glyphSurfOverlay, charWid, charHei);

if (!data[@ CHAR.BBOX]) // direct
{
    surface_set_target(glyphSurf);
    draw_clear_alpha(0,0);
    
    draw_set_font(fntTemp);
    iui_align_center();
    iui_label(charWid/2, charHei/2, char, c_white);
    iui_align_pop();
    draw_set_font(fntOWO);
    
    surface_reset_target();
}
else
{
    var _surf = surface_create(charWid, charHei);
    
    // Draw glyph to temp surface
    surface_set_target(_surf);
    draw_clear_alpha(0,0);
    
    draw_set_font(fntTemp);
    iui_align_center();
    iui_label(charWid/2, charHei/2, char, c_white);
    iui_align_pop();
    draw_set_font(fntOWO);
    
    surface_reset_target();
    
    
    // Draw temp surface to final surface, cropped.
    surface_set_target(glyphSurf);
    draw_clear_alpha(0,0);
    draw_surface_part(_surf, data[@ CHAR.X], data[@ CHAR.Y], data[@ CHAR.W], data[@ CHAR.H], data[@ CHAR.X], data[@ CHAR.Y]);
    surface_reset_target();
    
    surface_free(_surf);
}

#define build_glyph_surface_preview
///build_glyph_surface_preview(index)
/*
    Updates glyph surface from glyph index for display
*/

// var
#args index
var glyphX = index % gridWid, glyphY = index div gridWid, char = "";
if (index < 0)
    return -1;

// Build character to draw
switch (glyphY)
{
    case 0: // Choseong beol 1
        char = chr($AC00 + ((glyphX * 21) + 0) * 28 + 16);
        break;
    
    case 1: // Choseong beol 2
        char = chr($AC00 + ((glyphX * 21) + 8) * 28 + 16);
        break;
        
    case 2: // Jungseong
        char = chr($AC00 + glyphX * 28 + 16);
        break;
    
    case 3: // Jongseong beol 1
        char = chr($AC00 + glyphX);
        break;
    
    case 4: // Choseong beol 2
        char = chr($AC00 + ((1 * 21) + 8) * 28 + glyphX);
        break;
        
    case 5: // Compat. Jamo
    case 6:
        var _off = $3130 + (index - gridWid * 5);
        
        if (_off >= $3130 && _off <= $3163)
            char = chr(_off);
        break;
        
    default: // ASCII
        char = chr(index - gridWid * 7);
}


// clear surface
if (surface_exists(glyphSurf))
    surface_resize(glyphSurf, charWid, charHei);
else
    glyphSurf = surface_create(charWid, charHei);
surface_resize(glyphSurfOverlay, charWid, charHei);

surface_set_target(glyphSurf);
draw_clear_alpha(0,0);


// Draw glyph to surface
draw_set_font(fntTemp);
iui_align_center();
iui_label(charWid/2, charHei/2, char, c_white);
iui_align_pop();
draw_set_font(fntOWO);

surface_reset_target();