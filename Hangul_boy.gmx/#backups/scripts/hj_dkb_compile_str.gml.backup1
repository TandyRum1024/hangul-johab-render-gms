// 2019-02-11 06:14:48
///hj_dkb_compile_str(string)
/*
    스트링을 그리기 좋은 데이터로 컴파일하고, 컴파일한 결과를 반환합니다.
    자주 그려지는 글자에 적용하면 더 나을지도?
*/

var _strarray = -1, _strlen = string_length(argument0);
var _char, _prev = "", _ord, _kr;
var _head, _body, _tail, _headidx, _bodyidx, _tailidx;
var _arr = -1;
var _type = -1;
for (var i=0; i<_strlen; i++)
{
    _arr = -1;
    _char = string_char_at(argument0, i + 1);
    _ord = ord(_char);
    
    if (_char == "#" && _prev != "\") // 다음줄
    {
        _arr[0] = 0; // 타입 [다음줄, ASCII, 조합, 자모]
        _arr[1] = _ord; // 인덱스(들)
        _arr[2] = 0;
        _arr[3] = 0;
    }
    else if (_ord <= $FF) // ASCII
    {
        _arr[0] = 1; // 타입 [다음줄, ASCII, 조합, 자모]
        _arr[1] = _ord; // 인덱스(들)
        _arr[2] = 0;
        _arr[3] = 0;
    }
    else if (_ord >= $AC00 && _ord <= $D7AF) // 조합형 한글
    {
        _kr = _ord - $AC00;
        
        // 초/중/종성 구하기 & 벌 (오프셋) 구하기
        _head = (_kr div 588); // 초성
        _body = ((_kr % 588) div 28); // 중성
        _tail = (_kr % 28); // 종성 (받침)
        
        _headidx = _head + 1;
        _bodyidx = _body + 1;
        _tailidx = _tail + global.hjLUTTail[@ _body];
        
        if (_tail == 0) // 받침 없는 글자
        {
            _headidx += global.hjLUTHead[@ _body];
            _bodyidx += global.hjLUTBody[@ _head];
        }
        else // 받침 있는 글자
        {
            _headidx += global.hjLUTHeadWithTail[@ _body];
            _bodyidx += global.hjLUTBodyWithTail[@ _head];
        }
        
        _arr[0] = 2;
        _arr[1] = _headidx; // 인덱스(들)
        _arr[2] = _bodyidx;
        _arr[3] = _tailidx;
    }
    else if (_ord >= $3130 && _ord <= $3163) // 한글 자모
    {
        _kr = _ord - $3130;
        
        _arr[0] = 3;
        _arr[1] = global.hjLUTJamo[@ _kr]; // 인덱스(들)
        _arr[2] = 0;
        _arr[3] = 0;
    }
    else // ????
    {
        _arr[0] = -1;
        _arr[1] = 0;
        _arr[2] = 0;
        _arr[3] = 0;
    }
    
    _strarray[i] = _arr;
    _prev = _char;
}

return _strarray;
