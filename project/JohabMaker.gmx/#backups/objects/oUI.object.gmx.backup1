// 2020-01-17 04:12:13
#event create
iui_init();
iui_init_vars();
ui_vars();

hj_init();

// WINDOSSSSASDSADSAdWdasd
WIN_WID = room_width;
WIN_HEI = room_height;

/* 
    FONT RELATED
    ==================
*/
fntCurrent = -1;    // Currently loaded font for rendering glyphs; includes ALL the glyphs in the font.
fntName = "NONE";   // Name of currently loaded font
fntPath = "";       // Path of currently loaded font
fntSize = 16;       // Size of font for rendering
FNT_ASCII = true;
FNT_GRID = true;
FNT_DKB = false;
FNT_MIDDLE = true;
FNT_LAST = true;

/* 
    GLYPH RELATED
    ==================
*/
// Grid size
choRows = 4;
jungRows = 2;
jongRows = 2;
jamoRows = 2;
asciiRows = (127 div 28) + 1;

gridWid = 28;
gridHei = choRows + jungRows + jongRows + jamoRows + asciiRows; // starts from 0

// Character related
charLen = gridWid * gridHei; // Total numbers of cells
charWid = 16; // Single Cell's size/unit... default = 16px monospaced
charHei = 16;
charAsciiWid = 8; // Ascii size
charAsciiHei = 16;
charSelected = -1; // Currently selected character
charData = ds_list_create(); // List of glyph's data made out of array
enum CHAR
{
    SOURCE = 0,
    X,
    Y,
    OCCUPIED
}
// 0 - The glyph to get original texture (ex : '갈')
// 1 - baked Glyph surface
// 2 - Glyph mask
// 3..4 - glyph offset x and y

charOffX = 0; // for storing currently selected glyph's offset and source character
charOffY = 0;
charSrc = "";

/* 
    TEXTURES
    ==================
*/
updatePreview = false;

// Font texture for exporting & preview
fntSprite = -1;
fntAsciiSprite = -1;
fntTex = surface_create(gridWid * charWid, gridHei * charHei);
fntAsciiTex = surface_create(32 * charAsciiWid, 8 * charAsciiHei); // Ascii texture
previewTex = surface_create(gridWid * charWid, gridHei * charHei);
previewAsciiTex = surface_create(32 * charAsciiWid, 8 * charAsciiHei);
updateFontSurf = false; // Flag for updating font surface

// Font mask related
maskOverlay = surface_create(charWid, charHei); // rectangle overlay for preview
maskPreview = surface_create(charWid, charHei); // cached mask preview surface
maskTemp = surface_create(charWid, charHei); // temp surface for mask building before applying to character
clipboardTex = surface_create(charWid, charHei);

// TEST : Atlas
bakedAtlas = -1;
maskAtlas = -1;
glyphTemp = surface_create(charWid, charHei);
clear_atlas();

textureDestroyed = false; // Texture was destroyed and must load last backup?

/* 
    WINDOW
    ==================
*/
// Font mask editing window
winCropX = 0;
winCropY = uToolbarHei;
winCropPanelSize = 250;
winCropTexSize = 250;
winCropLocalX = 0;
winCropLocalY = 0;

cropmode = 0;
cropping = false;
cropShow = false;
cropX1 = 0;
cropY1 = 0;
cropX2 = 0;
cropY2 = 0;


/* 
    ETC
    ==================
*/
fntLoadRequest = false;
fntLoadPath = "";
projectLoadRequest = false;
projectLoadPath = "";
projectLoad = false;

exportHeaderRequest = false;
exportHeaderPath = "";

// shashlik
PEPPERONI_SECRET = false;
PEPPIS = false;
PEP_X = 0;
PEP_Y = 0;

// Camera stuff
camVX = 0;
camVY = 0;
camX = (gridWid * charWid) >> 1;
camY = (gridHei * charHei) >> 1;
camZ = 1;
view_wport[0] = WIN_WID;
view_hport[0] = WIN_HEI;

draw_set_font(fntOWO);
reset_char_data_all();
build_font_tex(true, c_black, 1);

window_set_cursor(cr_none);
kia_init();

#event step I/O, Camera
iui_update_io();
ui_update();

if (iui_kbFocusItem == -1 && !uiModal)
{
    var moveH = keyboard_check(vk_right) - keyboard_check(vk_left);
    var moveV = keyboard_check(vk_down) - keyboard_check(vk_up);
    var moveW = keyboard_check(vk_subtract) - keyboard_check(vk_add);
    
    // camVX += 0.5 * moveH;
    // camVY += 1 * moveV;
    var mult = 2;
    if (keyboard_check(vk_shift))
        mult = 4;
    else if (keyboard_check(vk_control))
        mult = 1;
        
    camX += moveH * mult;
    camY += moveV * mult;
    camZ += (0.005 * moveW) * mult;
    camZ = clamp(camZ, 0.001, 2);
}

var _vwid = WIN_WID * camZ;
var _vhei = WIN_HEI * camZ;
view_xview[0] = camX - (_vwid * 0.5);
view_yview[0] = camY - (_vhei * 0.5);
view_wview[0] = _vwid;
view_hview[0] = _vhei;

// debug modal menu
if (!uiModal && keyboard_check_pressed(vk_f12))
{
    uiModal = true;
    uiModalMsg = "DEBUG";
    uiModalState = UI_MODAL.DEBUG;
    uiModalInfo = false;
}

if (!uiModal && keyboard_check_pressed(vk_f11))
{
    uiModal = true;
    uiModalMsg = "LOADING";
    uiModalState = UI_MODAL.LOADING;
    uiModalInfo = false;
}

// Escape modal menu
if (uiModal && keyboard_check_pressed(vk_escape))
{
    uiModal = false;
    iui_activeItem = -1;
    iui_hotItem = -1;
}

#section update keystrokes for preview

if ((uFontInputActive || uTestInputActive) && uiModal)
{
    if (ime_get(kia_hex_to_dec(string(window_handle()))))
        uInputKor = !uInputKor;
    
    // Update keystrokes
    // Typing
    if (keyboard_string != "")
    {
        var _alphabet = (ord(string_lower(iui_keyChar)) - 97);
        if (uInputKor && _alphabet >= 0 && _alphabet <= 25)
        {
            if (uTestInputActive)
                uTestInput += kia_input(_alphabet);
            if (uFontInputActive)
                uFontInput += kia_input(_alphabet);
        }
        else
        {
            var _in = "";
            
            // Add unfinished korean glyph first
            if (kia_type != "")
                _in += kia_type;
            
            // Add typed glyph then
            if (iui_keyChar == "#")
                _in += "\#";
            else
                _in += iui_keyChar;
            
            if (uTestInputActive)
                uTestInput += _in;
            if (uFontInputActive)
                uFontInput += _in;

            kia_type = "";
        }
        
        keyboard_string = "";
    }
    
    // Enter key
    if (keyboard_check_pressed(vk_enter))
    {
        var _in = "";
        
        // Add unfinished korean glyph first
        if (kia_type != "")
        {
            _in += kia_type;
            kia_type = "";
        }
        
        _in += "#";
        
        if (uTestInputActive)
            uTestInput += _in;
        if (uFontInputActive)
            uFontInput += _in;
    }
    
    // arrow key / interrupt
    if (keyboard_check_pressed(vk_up) || keyboard_check_pressed(vk_down) || keyboard_check_pressed(vk_left) || keyboard_check_pressed(vk_right))
    {
        if (uTestInputActive)
            uTestInput += kia_type;
        if (uFontInputActive)
            uFontInput += kia_type;
        kia_type = "";
    }
    
    // Deleting
    if (keyboard_check_pressed(vk_backspace))
    {
        uInputBackCtr = 0;
        uInputBackHolding = true;
    }
    else if (keyboard_check(vk_backspace))
        uInputBackCtr++;
    else
        uInputBackHolding = false;
        
    if (keyboard_check_pressed(vk_backspace) || (uInputBackHolding && (uInputBackCtr > 30) && (uInputBackCtr & 1)))
    {
        if (kia_remove())
        {
            if (uTestInputActive)
            {
                var _strlen = string_length(uTestInput);
                uTestInput = string_delete(uTestInput, _strlen, 1);
                    
                // check for stray escaped sharp
                if (string_char_at(uTestInput, _strlen - 1) == "\")
                    uTestInput = string_delete(uTestInput, _strlen - 1, 1);
            }
            if (uFontInputActive)
            {
                var _strlen = string_length(uFontInput);
                uFontInput = string_delete(uFontInput, _strlen, 1);
                
                // check for stray escaped sharp
                if (string_char_at(uFontInput, _strlen - 1) == "\")
                    uFontInput = string_delete(uFontInput, _strlen - 1, 1);
            }
        }
    }
}

#section glyph selecting & mouse logic & cropping logic
/// Get local X/Y inside crop window
// zoom ratio of panel size and cell size
var zoomRatio = winCropPanelSize / max(charWid, charHei);
var zoomWid = charWid * zoomRatio;
var zoomHei = charHei * zoomRatio;
// offset of clickable panel
var winhalf = winCropPanelSize >> 1;
var panelOffX = winhalf - (zoomWid >> 1);
var panelOffY = 42 + winhalf - (zoomHei >> 1);
// local x y in cell space
winCropLocalX = floor((iui_inputX - (winCropX + panelOffX)) / zoomRatio);
winCropLocalY = floor((iui_inputY - (winCropY + panelOffY)) / zoomRatio);

// Mouse logic
if (!uiModal)
{
    if (winCropLocalX >= 0 && winCropLocalX < charWid &&
        winCropLocalY >= 0 && winCropLocalY < charHei)
    {
        uiCursorInCrop = true;
        
        // mask editing
        if (mouse_check_button_pressed(mb_left))
        {
            cropping = true;
            cropShow = true;
            
            cropX1 = winCropLocalX;
            cropY1 = winCropLocalY;
            cropX2 = winCropLocalX;
            cropY2 = winCropLocalY;
        }
    }
    else
    {
        uiCursorInCrop = false;
        
        // glyph selecting
        if (mouse_check_button_pressed(mb_left) && winCropLocalX >= charWid && iui_inputY >= (uToolbarHei + 2)) // We don't want the users able to click through the UI panel
        {
            cropping = false; 
            cropShow = false;
            
            var _mx = floor(mouse_x / charWid);
            var _my = floor(mouse_y / charHei);
            
            if (_mx >= 0 && _mx <= gridWid &&
                _my >= 0 && _my <= gridHei)
            {
                select_char(_mx + _my * gridWid);
                updatePreview = true;
            }
        }
    }
}

// Crop logic
if (iui_keyMod & (1 << eKEYMOD.SHIFT))
    cropmode = 1;
else if (iui_keyMod & (1 << eKEYMOD.ALT))
    cropmode = 2;
else
    cropmode = 0;

#section more cropping logic
/// More crop / masking logic
if (cropping)
{
    // Disable mask editing once the user has released mouse1
    if (mouse_check_button_released(mb_left))
    {
        cropping = false;
        cropShow = false;
        
        var _tmp;
        if (cropX2 < cropX1)
        {
            _tmp = cropX2;
            cropX2 = cropX1;
            cropX1 = _tmp;
        }
        
        if (cropY2 < cropY1)
        {
            _tmp = cropY2;
            cropY2 = cropY1;
            cropY1 = _tmp;
        }
        
        if (cropmode == 1)
            add_char_mask_to(maskTemp, cropX1, cropY1, cropX2, cropY2);
        else if (cropmode == 2)
            subtract_char_mask_to(maskTemp, cropX1, cropY1, cropX2, cropY2);
        else
            set_char_mask_to(maskTemp, cropX1, cropY1, cropX2, cropY2);
        
        build_char_surface_preview(charSelected);
    }
    else
    {
        cropX2 = winCropLocalX;
        cropY2 = winCropLocalY;
    }
}

#section Loading font & project load/save wait logic
if (fntLoadRequest)
{
    fntLoadRequest = false;
    load_font(fntLoadPath, fntSize);
    clear_char_mask_to(maskTemp, 0);
    
    uiModal = false;
    iui_activeItem = -1;
    iui_hotItem = -1;
}

if (projectLoadRequest)
{
    projectLoadRequest = false;
    
    if (projectLoad)
        load_project(projectLoadPath);
    else
        save_project(projectLoadPath);
    
    uiModal = false;
    iui_activeItem = -1;
    iui_hotItem = -1;
}

if (exportHeaderRequest)
{
    exportHeaderRequest = false;
    var _result = export_font_header(exportHeaderPath, cbExportHeaderGenComments, cbExportHeaderTrimBlanks);
    
    // message
    if (_result)
    {
        uiMsgTime = room_speed;
        uiMsg = "성공적으로 헤더 파일을 저장하였읍니다.";
    }
    else
    {
        uiMsgTime = room_speed;
        uiMsg = "헤더 파일을 저장하는데 문제가 있었읍니다...";
    }
    
    uiModal = false;
    iui_activeItem = -1;
    iui_hotItem = -1;
}

#event step_begin Surface heartbeat & window size
// "AAGAGAAAGAAAAGAGGGGAAAGAGAAAGAAGASOAOSSSOASSSOSSOSSSOSSSSOSISISISOSIDIOSMIO"
// - Wilhelm willy wanker, 1829
var _wid = window_get_width(), _hei = window_get_height();
if ((_wid != 0 && _hei != 0) &&
    _wid != WIN_WID || _hei != WIN_HEI)
{
    WIN_WID = _wid;
    WIN_HEI = _hei;
}

if (!surface_exists(maskTemp))
    maskTemp = surface_create(charWid, charHei);
    
if (!surface_exists(maskPreview))
{
    maskPreview = surface_create(charWid, charHei);
    
    // if (!surface_exists(maskTemp))
    //     maskTemp = surface_create(charWid, charHei);
    
    build_char_surface_preview(charSelected);
}

if (!surface_exists(maskOverlay))
    maskOverlay = surface_create(charWid, charHei);

if (!surface_exists(fntTex))
{
    fntTex = surface_create(WIN_WID, WIN_HEI);
    build_font_tex();
    // build_glyph_surface(charSelected);
}

if (!surface_exists(fntAsciiTex))
{
    fntAsciiTex = surface_create(WIN_WID, WIN_HEI);
    build_font_tex();
}

if (uiModal)
{
    if (uiModalState == UI_MODAL.EXPORT)
    {
        if (!surface_exists(previewTex))
        {
            build_font_tex_ext(cbExportGrid, c_black, cbExportBG);
            var _w = surface_get_width(fntTex), _h = surface_get_height(fntTex);
            previewTex = surface_create(_w, _h);
            surface_copy(previewTex, 0, 0, fntTex);
            build_font_tex();
        }
        
        if (!surface_exists(previewAsciiTex))
        {
            build_font_tex_ext(cbExportGrid, c_black, cbExportBG);
            var _w = surface_get_width(fntAsciiTex), _h = surface_get_height(fntAsciiTex);
            previewAsciiTex = surface_create(_w, _h);
            surface_copy(previewAsciiTex, 0, 0, fntAsciiTex);
            build_font_tex();
        }
    }
}

#event other_game_end
johab_die();

#event draw update glyph overlay

var zoomRatio = winCropPanelSize / max(charWid, charHei);
var zoomWid = charWid * zoomRatio;
var zoomHei = charHei * zoomRatio;
var winhalf = winCropPanelSize >> 1;
var panelOffX = winhalf - (zoomWid >> 1);
var panelOffY = 42 + winhalf - (zoomHei >> 1);

var lx = floor((window_mouse_get_x() - (winCropX + panelOffX)) / zoomRatio);
var ly = floor((window_mouse_get_y() - (winCropY + panelOffY)) / zoomRatio);

surface_set_target(maskOverlay);
draw_clear_alpha(0, 0);

var data = charData[| charSelected];

if (lx >= 0 && lx <= charWid &&
    ly >= 0 && ly <= charHei)
{
    // draw pos
    iui_rect(lx, ly, 1, 1, c_red);
}

// draw bbox if set
var _col = c_yellow;
var _alpha = 0.8;

if (cropShow)
{
    if (cropmode == 1)
        _col = c_blue;
    else if (cropmode == 2)
        _col = c_red;
    
    var bx = min(cropX1, cropX2), by = min(cropY1, cropY2), bw = abs(cropX2 - cropX1), bh = abs(cropY2 - cropY1);
    iui_rect_alpha(bx, by, bw, 1, _col, _alpha);
    iui_rect_alpha(bx, by, 1, bh, _col, _alpha);
    iui_rect_alpha(bx, by + bh, bw, 1, _col, _alpha);
    iui_rect_alpha(bx + bw, by, 1, bh + 1, _col, _alpha);
}

surface_reset_target();

#section draw glyphs!!
draw_clear(COL.GRAY);

// surface
var _sw = surface_get_width(fntTex), _sh = surface_get_height(fntTex);
var _ay = _sh + charHei * 2;
iui_rect(10, 10, _sw, _sh, COL.BASE); // shadow
draw_surface(fntTex, 0, 0); // draw hangul stuff

if (FNT_DKB && FNT_ASCII)
{
    iui_rect(10, _ay + 10, surface_get_width(fntAsciiTex), surface_get_height(fntAsciiTex), COL.BASE); // shadow
    draw_surface(fntAsciiTex, 0, _ay); // draw ascii if DKB884
}

// hints
var _hintwid = 128;
var _heady = 0;
var _bodyy = _heady + choRows * charHei;
var _taily = _bodyy + jungRows * charHei;
var _jamoy = _taily + jongRows * charHei;
var _asciiy = _jamoy + jamoRows * charHei;

iui_align_push(0, 2);
iui_rect(-_hintwid, _heady, _hintwid, 2, c_red);
iui_label_shadow(-_hintwid, _heady - 2, "초성 ("+ string(choRows) +"벌)", c_red, 1, 1, COL.BASE);

iui_rect(-_hintwid, _bodyy, _hintwid, 2, c_green);
iui_label_shadow(-_hintwid, _bodyy - 2, "중성 ("+ string(jungRows) +"벌)", c_green, 1, 1, COL.BASE);

iui_rect(-_hintwid, _taily, _hintwid, 2, c_aqua);
iui_label_shadow(-_hintwid, _taily - 2, "종성 ("+ string(jongRows) +"벌)", c_aqua, 1, 1, COL.BASE);

if (!FNT_DKB)
{
    iui_rect(-_hintwid, _jamoy, _hintwid, 2, c_yellow);
    iui_label_shadow(-_hintwid, _jamoy - 2, "자모", c_yellow, 1, 1, COL.BASE);
    
    if (FNT_ASCII)
    {
        iui_rect(-_hintwid, _asciiy, _hintwid, 2, c_orange);
        iui_label_shadow(-_hintwid, _asciiy - 2, "ASCII 문자", c_orange, 1, 1, COL.BASE);
    }
}
else if (FNT_ASCII)
{
    iui_label_shadow(0, _ay, "ASCII 문자 (편집불가)", c_yellow, 1, 1, COL.BASE);
}
iui_align_pop();

// Draw glyph pick hint
var _mx = floor(mouse_x / charWid) * charWid;
var _my = floor(mouse_y / charHei) * charHei;
var _sx = (charSelected % gridWid) * charWid;
var _sy = (charSelected div gridWid) * charHei;

iui_rect_alpha(_mx, _my, charWid, charHei, $FFFFFF, 0.25); // hover
iui_rect_alpha(_sx, _sy, charWid, charHei, $FF00FF, 0.3); // current
#section Texture update

if (updateFontSurf)
{
    updateFontSurf = false;
    
    // show_debug_message("Building characters...");
    // build_char_surface_all();
    show_debug_message("Building font texture...");
    build_font_tex();
    
    // reset preview glyph
    build_char_surface_preview(charSelected);
    
    uiModal = false;
    iui_activeItem = -1;
    iui_hotItem = -1;
}

if (updatePreview)
{
    updatePreview = false;
    build_char_surface_preview(charSelected);
}

#event draw_gui
uiActive = !uiModal;

iui_inputX = window_mouse_get_x();
iui_inputY = window_mouse_get_y();
iui_inputDown = mouse_check_button(mb_left);

var _generalmargin = 10;
var _smallmargin = 20, _bigmargin = 42;
var _halfmargin = _bigmargin / 1.5;
var _winhalfw = WIN_WID >> 1, _winhalfh = WIN_HEI >> 1;

iui_begin();

iui_align_center();

/*
    TOOL UI BG
    ============
*/
iui_rect(0, 0, WIN_WID, uToolbarHei, uBGCol);
iui_rect(0, uToolbarHei, WIN_WID, 2, COL.WHITE);
uCurrentTab = ui_tab(0, 0, WIN_WID, 24, iui_pack("@=(^0^)", "프로젝트", "글꼴"), uCurrentTab);
iui_align_pop();

/*
    ACTUAL UI
    ============
*/
switch (uCurrentTab)
{
    default:
    case 0:
        /*
            MAIN TAB
            ============
        */
        var _topmargin = _bigmargin;
        
        // info
        
        // help
        var _helpy = _topmargin + _bigmargin;
        iui_label(_smallmargin, _helpy, "방향 단추로 화면 이동#+ 와 - 단추로 확대 / 축소#맨 위 표시줄을 이용하여 메뉴 창을 변경하십시오.", COL.HIGHLIGHT);
        
        // literally bullshit
        iui_align_push(fa_center, fa_top);
        // iui_label(_winhalfw, _topmargin + _bigmargin, "방향키로 화면 이동#+ & - 로 줌 인/아웃#맨 위에 있는 표시줄을 이용해 메뉴를 이동하세요", COL.WHITE);
        iui_label(_winhalfw, _topmargin, "조합형 글꼴 도우미 | ZIK@2019", COL.HIGHLIGHT);
        iui_label(_winhalfw, _topmargin + _bigmargin, ".TTF 화일을 불러와 조합형 한글 렌더링에 사용되는#비트맵 글꼴 제작을 도와주는 프로그램입니다.", COL.WHITE);
        iui_label(_winhalfw, _topmargin + _bigmargin * 2 - 10, "마우스로 편집할 글자를 선택한 뒤 좌측의 판을 이용해#마스크를 생성해 글자의 원하는 부분만 떼어내세요.#그 다음 아래의 버튼들을 이용해 마스크를 적용시키거나 여러 동작을 하실 수 있읍니다.", COL.HIGHLIGHT);
        iui_align_pop();
        break;
    
    case 1:
        /*
            MAIN TAB
            ============
            preview & export & reload
        */
        var _leftmarginA = _smallmargin;
        var _topmargin = _bigmargin;
        
        
        /// buttons
        var btnPreview = ui_button(_leftmarginA, _topmargin, 150, 42, "미리보기");
        var btnExport = ui_button(_leftmarginA, _topmargin + _bigmargin + 10, 150, 42, "글꼴 내보내기");
        var btnSave = ui_button(_leftmarginA + 180, _topmargin, 150, 42, "프로젝트 저장");
        var btnLoad = ui_button(_leftmarginA + 180, _topmargin + _bigmargin + 10, 150, 42, "프로젝트 불러오기");
        var btnReset = ui_button(_leftmarginA + 360, _topmargin, 150, 42, "모두 리셋");
        var btnReload = ui_button(_leftmarginA + 360, _topmargin + _bigmargin + 10, 150, 42, "텍스쳐 재생성");
        
        
        /// BUTTON FUNCS
        if (btnPreview)
        {
            uiModal = true;
            uiModalMsg = "글꼴 미리보기";
            uiModalState = UI_MODAL.PREVIEW;
            
            // build font
            if (sprite_exists(fntSprite))
                sprite_delete(fntSprite);
            
            show_debug_message("ASCII SZ BEFORE PREVIEW : " + string(charAsciiWid) + ", " + string(charAsciiHei));
                
            build_font_tex_ext(false, 0, 0);
            fntSprite = sprite_create_from_surface(fntTex, 0, 0, gridWid * charWid, gridHei * charHei, false, false, 0, 0);
            fntAsciiSprite = sprite_create_from_surface(fntAsciiTex, 0, 0, 32 * charAsciiWid, 8 * charAsciiHei, false, false, 0, 0);
            build_font_tex();
            
            show_debug_message("> SURFSZ : " + string(surface_get_width(fntAsciiTex)) + ", " + string(surface_get_height(fntAsciiTex)));
            show_debug_message("> SPRSZ : " + string(sprite_get_width(fntAsciiSprite)) + ", " + string(sprite_get_height(fntAsciiSprite)));
            
            if (FNT_DKB) // dkb844 - set han & asc font & size
            {
                hj_change_font_ext(-1, -1, charWid, charHei, 8, 16);
                
                if (FNT_ASCII)
                {
                    // set ascii attribs also
                    global.hjSpriteAscii = fntAsciiSprite;
                    global.hjCharWidAscii = charAsciiWid;
                    global.hjCharHeiAscii = charAsciiHei;
                }
                else
                {
                    // use default sprite
                    global.hjSpriteAscii = sprYayoC64;
                    global.hjCharWidAscii = charWid;
                    global.hjCharHeiAscii = charHei;
                }
            }
            else // previous / compat
            {
                var _w = 16, _h = 16;
                if (FNT_ASCII)
                {
                    _w = charWid;
                    _h = charHei;
                }
                
                hj_comp_change_font(charWid, charHei, _w, _h, FNT_MIDDLE, FNT_LAST);
            }
        }
        if (btnExport)
        {
            uiModal = true;
            uiModalMsg = "글꼴 내보내기";
            uiModalState = UI_MODAL.EXPORT;
            
            build_font_tex_ext(cbExportGrid, c_black, cbExportBG);
            surface_resize(previewTex, surface_get_width(fntTex), surface_get_height(fntTex));
            surface_resize(previewAsciiTex, surface_get_width(fntAsciiTex), surface_get_height(fntAsciiTex));
            surface_copy(previewTex, 0, 0, fntTex);
            surface_copy(previewAsciiTex, 0, 0, fntAsciiTex);
            build_font_tex();
        }
        if (btnSave)
        {
            var _date = date_current_datetime();
            var _path = get_save_filename_ext("프로젝트 파일|*.jort", "johab_"+string(date_get_month(_date))+"_"+string(date_get_day(_date))+"_"+string(date_get_hour(_date))+"_"+string(date_get_second(_date))+".jort", working_directory, "불러올 프로젝트 경로 선택");
            
            if (_path != "")
            {
                uiModal = true;
                uiModalMsg = "프로젝트 저장하는 중...";
                uiModalState = UI_MODAL.MESSAGE;
                uiModalInfo = false;
                
                projectLoad = false;
                projectLoadRequest = true;
                projectLoadPath = _path;
            }
        }
        if (btnLoad)
        {
            var _path = get_open_filename_ext("프로젝트 파일|*.jort", "johab.jort", working_directory, "프로젝트 저장 경로 선택");
            if (_path != "")
            {
                uiModal = true;
                uiModalMsg = "프로젝트 불러오는 중...";
                uiModalState = UI_MODAL.MESSAGE;
                uiModalInfo = false;
                
                projectLoad = true;
                projectLoadRequest = true;
                projectLoadPath = _path;
            }
        }
        if (btnReset)
        {
            clear_atlas();
            build_char_surface_all();
            updateFontSurf = true;
            updatePreview = true;
        }
        if (btnReload)
        {
            build_char_surface_all();
            updateFontSurf = true;
            updatePreview = true;
        }
        break;
    
    case 2:
        /*
            FONT TAB
            ============
            set font & font size & cell size
        */
        var _leftmarginA = _smallmargin;
        var _leftmarginB = _smallmargin + 128 + (_bigmargin << 1) + 100;
        var _rightmargin = WIN_WID - 300;
        var _topmargin = _bigmargin;
        var _itemy = _topmargin + _smallmargin;
        
        /// load & reload section
        iui_label(_leftmarginA, _topmargin, "현재 글꼴 : " + string(fntName), COL.HIGHLIGHT);
        var btnLoad = ui_button(_leftmarginA, _itemy, 240, 42, ".TTF 불러오기");
        var btnReload = ui_button(_leftmarginA, _itemy + 52, 240, 42, ".TTF 다시 불러오기");
        
        /// texture info
        iui_label(_rightmargin, _topmargin, "격자 최종 크기 : [" + string(gridWid) + ", " + string(gridHei) + "]", uTextCol);
        iui_label(_rightmargin, _topmargin + _bigmargin, "텍스쳐 사이즈 : [" + string(gridWid * charWid) + ", " + string(gridHei * charHei) + "]", uTextCol);
        
        /// font attributes section (1)
        _itemy += _smallmargin;
        var _tbwid = 50;
        var _off = _leftmarginB + _bigmargin;
        iui_align_push(fa_middle, fa_top);
        iui_label(_leftmarginB + 70, _topmargin, "[폰트 불러오기 옵션]#(다시 불러오기 필요)", COL.HIGHLIGHT);
        iui_label(_leftmarginB + 350, _topmargin, "[폰트 형식 옵션]#(변경시 모든 데이터 리셋)", COL.HIGHLIGHT);
        iui_align_pop();
        
        iui_align_push(fa_right, fa_top);
        iui_label(_off, _itemy, "글꼴 크기 : ", uTextCol);
        iui_label(_off, _itemy + _bigmargin, "격자 크기 : ", uTextCol);
        iui_label(_off + _tbwid + 5 + (string_width("X") >> 1), _itemy + _bigmargin, "X", uTextCol);
        
        tbFntSize = ui_textbox_numberonly(_off, _itemy, _tbwid, 32, string(tbFntSize), "FONTSIZE", 0);
        tbCellWid = ui_textbox_numberonly(_off, _itemy + _bigmargin, _tbwid, 32, string(tbCellWid), "CELLWID", 1);
        tbCellHei = ui_textbox_numberonly(_off + _tbwid + 10, _itemy + _bigmargin, _tbwid, 32, string(tbCellHei), "CELLHEI", 1);
        
        /// font attributes section (2)
        _off += 300;
        
        iui_label(_off, _itemy, "도깨비 한글 8x4x4벌 : ", uTextCol);
        cbDok844 = ui_checkbox(_off + 2, _itemy, 16, 16, cbDok844, "HAN844");
        
        iui_label(_off, _itemy + _bigmargin, "ASCII 문자 사용 : ", uTextCol);
        cbAscii = ui_checkbox(_off + 2, _itemy + _bigmargin, 16, 16, cbAscii, "ASCII");
        
        if (!FNT_DKB)
        {
            iui_label(_off + 180, _itemy, "초/종성 추가 벌 : ", uTextCol);
            cbSpecialBody = ui_checkbox(_off + 2 + 180, _itemy, 16, 16, FNT_MIDDLE, "SPECIALBODY");
            ui_tooltip(_off + 2 + 180, _itemy, 16, 16, "중성 모양에 따라 초/종성에 별도의 벌을 사용합니다.#(=global.hjCompSpecialMiddle)", -1, c_black, false, false, 0);
            
            iui_label(_off + 180, _itemy + _bigmargin, "초/중성 추가 벌 : ", uTextCol);
            cbSpecialTail = ui_checkbox(_off + 2 + 180, _itemy + _bigmargin, 16, 16, FNT_LAST, "SPECIALTAIL");
            ui_tooltip(_off + 2 + 180, _itemy + _bigmargin, 16, 16, "종성 여부에 따라 초/중성에 별도의 벌을 사용합니다.#(=global.hjCompSpecialLast)", -1, c_black, false, false, 0);
        }
        else
        {
            iui_label(_off + 180, _itemy, "ASCII 격자 크기", uTextCol);
            iui_label(_off + 165 - _tbwid + (string_width("X") >> 1), _itemy + _smallmargin, "X", uTextCol);
            tbCellAsciiWid = ui_textbox_numberonly(_off + 160 - _tbwid * 2, _itemy + _smallmargin, _tbwid, 32, string(tbCellAsciiWid), "ASCIIWID", 1);
            tbCellAsciiHei = ui_textbox_numberonly(_off + 170 - _tbwid, _itemy + _smallmargin, _tbwid, 32, string(tbCellAsciiHei), "ASCIIHEI", 1);
        }
        
        // Checkboxes check
        if (FNT_ASCII != cbAscii) // USE ASCII (comp)
        {
            FNT_ASCII = cbAscii;
            reset_char_data_all();
            clear_atlas();
            build_char_surface_all();
            updateFontSurf = true;
        }
        
        if (FNT_DKB != cbDok844) // USE DKB844 (fuck)
        {
            FNT_DKB = cbDok844;
            reset_char_data_all();
            clear_atlas();
            build_char_surface_all();
            updateFontSurf = true;
        }
        
        if (FNT_MIDDLE != cbSpecialBody) // USE YET ANOTHER DAMN SPECIAL SUITS FOR SPECIFIC MIDDLE STUFF
        {
            FNT_MIDDLE = cbSpecialBody;
            global.hjCompSpecialMiddle = FNT_MIDDLE; // OH NO FUCk!!
            reset_char_data_all();
            clear_atlas();
            build_char_surface_all();
            updateFontSurf = true;
        }
        
        if (FNT_LAST != cbSpecialTail) // USE YET ANOTHER DAMN SPECIAL SUITS FOR CHARACTERS WITHOUT TAIL PART
        {
            FNT_LAST = cbSpecialTail;
            global.hjCompSpecialLast = FNT_LAST;
            reset_char_data_all();
            clear_atlas();
            build_char_surface_all();
            updateFontSurf = true;
        }
        
        if (tbCellAsciiWid != "" && charAsciiWid != real(tbCellAsciiWid)) // ASCII WID
        {
            charAsciiWid = real(tbCellAsciiWid);
            updateFontSurf = true;
        }
        
        if (tbCellAsciiHei != "" && charAsciiHei != real(tbCellAsciiHei)) // ASCII HEI
        {
            charAsciiHei = real(tbCellAsciiHei);
            updateFontSurf = true;
        }
        
        iui_align_pop();
        
        
        /// Buttons
        if (btnLoad)
        {
            var _path = get_open_filename("글꼴 파일|*.ttf", "글꼴을 선택해 주세요.");
            
            if (_path != "")
            {
                if (tbCellWid != "")
                    charWid = real(tbCellWid);
                else
                    charWid = 0;
                
                if (tbCellHei != "")
                    charHei = real(tbCellHei);
                else
                    charHei = 0;
                    
                if (tbFntSize != "")
                    fntSize = real(tbFntSize);
                else
                    fntSize = 0;
                
                show_debug_message("Path : " + _path);
                update_font_attribs();
                
                fntLoadRequest = true;
                fntLoadPath = _path;
                fntPath = _path;
                
                uiModal = true;
                uiModalMsg = "LOADING";
                uiModalState = UI_MODAL.LOADING;
                uiModalInfo = false;
            }
        }
        
        if (btnReload)
        {
            if (fntPath != "")
            {
                if (tbCellWid != "")
                    charWid = real(tbCellWid);
                
                if (tbCellHei != "")
                    charHei = real(tbCellHei);
                
                if (tbFntSize != "")
                    fntSize = real(tbFntSize);
                
                update_font_attribs();
                fntLoadRequest = true;
                fntLoadPath = fntPath;
                
                uiModal = true;
                uiModalMsg = "LOADING";
                uiModalState = UI_MODAL.LOADING;
                uiModalInfo = false;
            }
        }
        break;
    
    /*
    case 2:
        /*
            EXPORT TAB
            ============
        
        
        var _leftmarginA = _smallmargin;
        var _leftmarginB = _smallmargin + 300 + (_bigmargin << 1) + 100;
        var _rightmargin = WIN_WID - 300;
        var _topmargin = _bigmargin;
        
        // load & reload section
        var btnExport = ui_button(_leftmarginA, _topmargin + _bigmargin, 150, 42, "폰트 내보내기!");
        
        // Attribs
        var _off = _leftmarginB + _bigmargin;
        iui_align_push(fa_right, fa_top);
        
        iui_label(_off, _topmargin, "격자 내보내기 : ", uTextCol);
        iui_label(_off, _topmargin + _bigmargin, "배경 내보내기 : ", uTextCol);
        cbExportGrid = ui_checkbox(_off + _smallmargin, _topmargin, 16, 16, cbExportGrid, "EXPORT_GRID");
        cbExportBG = ui_checkbox(_off + _smallmargin, _topmargin + _bigmargin, 16, 16, cbExportBG, "EXPORT_BG");
        
        iui_align_pop();
        
        /// Buttons
        if (btnExport)
        {
            var _path = get_save_filename("PNG 폰트 이미지|*.png", "font" + string(charWid) + "x" + string(charWid));
            
            if (_path != "")
            {
                // export!
                export_font_tex(_path, cbExportGrid, cbExportBG, c_black);
            }
        }
        break;
    */
}


/*
    GLYPH EDITING
    ============
*/
var _data = charData[| charSelected];
var _winhalf = (winCropPanelSize * 0.5);
var _wincx = winCropX + _winhalf;

iui_align_center();
iui_rect(winCropX, winCropY, winCropPanelSize, 42, COL.HIGHLIGHT); // top title
iui_rect(winCropX, winCropY + 42, winCropPanelSize, WIN_HEI - (winCropY + 42), COL.BASE);
iui_label(_wincx, winCropY + 21, "글자 마스크", COL.BASE);
ui_tooltip(winCropX + winCropPanelSize - 42, winCropY, 42, 42, "마우스를 끌어 사각형을 그리면서#현재 선택된 글자의 마스크를 딸 수 있읍니다..#============#SHIFT 단추로 누적 모드#ALT 단추로 빼기 모드", 5, COL.BASE, false, true, COL.HIGHLIGHT2);

// inputs
iuiButtonShadow = false;
var _btnwid = winCropPanelSize / 3;
var _btnhei = 32;
var _btnhalf = _btnwid * 0.5;
var _btny = winCropY + winCropPanelSize + 42;
var btnSet = ui_button_icon(winCropX, _btny, _btnwid, _btnhei, "마스크 적용##BTNSET", 2, c_black);
var btnDel = ui_button_icon(winCropX + winCropPanelSize - _btnwid, _btny, _btnwid, _btnhei, "마스크 재설정#(처음으로 되돌리기)##BTNDEL", 4, c_black);
var btnAll = ui_button_icon(_wincx - _btnhalf, _btny, _btnwid, _btnhei, "선택한 글자와 같은 줄의 모든 글자에 적용##BTNALL", 3, c_black);
var btnFull = ui_button_icon(winCropX, _btny + _btnhei, _winhalf, _btnhei, "마스크 전체 영역 설정##BTNFULL", 6, c_black);
var btnEmpty = ui_button_icon(winCropX + _winhalf, _btny + _btnhei, _winhalf, _btnhei, "마스크 전체 영역 제외##BTNNONE", 7, c_black);
var btnCopy = ui_button_icon(winCropX, _btny + _btnhei * 2, _winhalf, _btnhei, "마스크 복사#(CTRL + C)##BTNCOPY", 8, c_black);
var btnPaste = ui_button_icon(winCropX + _winhalf, _btny + _btnhei * 2, _winhalf, _btnhei, "마스크 붙여넣기#(CTRL + V)##BTNPASTE", 9, c_black);

var _attribtopmargin = _btny + _btnhei * 4; // + (_bigmargin << 1);

iui_label(_wincx, _attribtopmargin, "-=[쌤플 글자]=-", uTextCol);
iui_label(_wincx, _attribtopmargin + _halfmargin * 3, "-=[글자 오프셋]=-", uTextCol);

if (_data != undefined)
{
    var _offmarginy = _attribtopmargin + _halfmargin * 3 + _smallmargin;
    iui_label(winCropX + _bigmargin, _offmarginy, "X : ", uTextCol);
    iui_label(winCropX + _bigmargin, _offmarginy + 42, "Y : ", uTextCol);
    
    _offmarginy -= 16;
    
    // check if the properties had changed
    var _newoffx = ui_textbox_numberonly(winCropX + _bigmargin, _offmarginy, 80, 32, charOffX, "CHAR_OFF_X", -128);
    var _newoffy = ui_textbox_numberonly(winCropX + _bigmargin, _offmarginy + 42, 80, 32, charOffY, "CHAR_OFF_Y", -128);
    
    ui_tooltip(_wincx - 40, _attribtopmargin + _smallmargin, 80, 32, "마스크가 씌워질 원본 글자를 지정합니다.#빈 칸은 미리 지정된 글자를 사용합니다.", -1, 0, false, false, false);
    var _newsrc = ui_textbox_hangul(_wincx - 40, _attribtopmargin + _smallmargin, 80, 32, charSrc, "CHAR_SRC");
    
    if (_newoffx != charOffX ||
        _newoffy != charOffY ||
        _newsrc != charSrc)
    {
        _newsrc = string_char_at(_newsrc, 1);
        
        charOffX = _newoffx;
        charOffY = _newoffy;
        charSrc = _newsrc;
        
        if (charOffX != "")
            _data[@ CHAR.X] = real(charOffX);
        if (charOffY != "")
            _data[@ CHAR.Y] = real(charOffY);
        _data[@ CHAR.SOURCE] = string(charSrc);
        
        build_char_surface(charSelected);
        updatePreview = true;
        updateFontSurf = true;
    }
}

iuiButtonShadow = true;
iui_align_pop();

// Draw glyph preview / crop panel view
var _zoomRatio = winCropTexSize / max(charWid, charHei);
var _zoomWid = charWid * _zoomRatio;
var _zoomHei = charHei * _zoomRatio;

var panelOffX = winCropX + _winhalf - (_zoomWid >> 1);
var panelOffY = 42 + winCropY + _winhalf - (_zoomHei >> 1);

iui_rect(panelOffX, panelOffY, _zoomWid, _zoomHei, 0);

// Mask preview
draw_surface_stretched(maskPreview, panelOffX, panelOffY, _zoomWid, _zoomHei);
// overlay
draw_surface_stretched(maskOverlay, panelOffX, panelOffY, _zoomWid, _zoomHei);


/*
    BUTTONS
*/
if (btnSet)
{
    // Copy mask to dest
    var _data = charData[| charSelected];
    /*
    if (is_array(_data) && surface_exists(_data[@ CHAR.MASK]))
        surface_copy(_data[@ CHAR.MASK], 0, 0, maskTemp);
    */
    if (is_array(_data) && _data[@ CHAR.OCCUPIED])
    {
        /*
        var _spr = _data[@ CHAR.MASK];
        if (sprite_exists(_spr))
            sprite_delete(_spr);
        _spr = sprite_create_from_surface(maskTemp, 0, 0, charWid, charHei, false, false, 0, 0);
        _data[@ CHAR.MASK] = _spr;
        */
        maskAtlas = edit_atlas_glyph(maskAtlas, charSelected, maskTemp);
    }
    
    build_char_surface(charSelected);
    updateFontSurf = true;
    updatePreview = true;
}

if (btnAll)
{
    var _y = charSelected div gridWid;
    var _data = charData[| charSelected];
    // var _mask;//_data[@ CHAR.MASK];
    maskTemp = get_atlas_glyph(maskAtlas, charSelected, maskTemp);
    var _srcx = _data[@ CHAR.X];
    var _srcy = _data[@ CHAR.Y];
    
    // Copy the mask surface & paste all over it
    for (var i=0; i<gridWid; i++)
    {
        var _off = _y * gridWid + i;
        var _data = charData[| _off];
        
        if (is_array(_data) && _data[@ CHAR.OCCUPIED] && _off != charSelected)
        {
            _data[@ CHAR.X] = _srcx;
            _data[@ CHAR.Y] = _srcy;
            
            maskAtlas = edit_atlas_glyph(maskAtlas, _off, maskTemp); // surface_copy(glyphTemp, 0, 0, glyphTemp);
            // sprite_assign(_data[@ CHAR.MASK], _mask);
            
            charData[| _off] = _data;
            build_char_surface(_off);
        }
    }
    
    updateFontSurf = true;
}

if (btnDel)
{
    var _data = charData[| charSelected];
    
    if (_data != undefined && _data[@ CHAR.OCCUPIED])
    {
        // var _mask = _data[@ CHAR.MASK];
        get_atlas_glyph(maskAtlas, charSelected, -1);
        
        // surface_copy(maskTemp, 0, 0, _mask);
        surface_set_target(maskTemp);
        draw_clear_alpha(0, 0);
        // draw_sprite(, 0, 0, 0);
        draw_surface(glyphTemp, 0, 0);
        surface_reset_target();
        updatePreview = true;
    }
    // build_char_surface(charSelected);
    // updateFontSurf = true;
}

if (btnFull)
{
    clear_char_mask_to(maskTemp, 1);
    updatePreview = true;
}

if (btnEmpty)
{
    clear_char_mask_to(maskTemp, 0);
    updatePreview = true;
}

var _ctrl = iui_keyMod & (1 << eKEYMOD.CTRL);
if (btnCopy || (uiActive && _ctrl && keyboard_check_pressed(ord('C'))))
{
    if (!surface_exists(clipboardTex))
        clipboardTex = surface_create(charWid, charHei);
    else
        surface_resize(clipboardTex, charWid, charHei);
        
    surface_copy(clipboardTex, 0, 0, maskTemp);
    
    // message
    uiMsgTime = room_speed;
    uiMsg = "마스크를 복사하였읍니다.";
}

if (btnPaste || (uiActive && _ctrl && keyboard_check_pressed(ord('V'))))
{
    if (surface_exists(clipboardTex))
    {
        surface_copy(maskTemp, 0, 0, clipboardTex);
        maskAtlas = edit_atlas_glyph(maskAtlas, charSelected, maskTemp);
        
        build_char_surface(charSelected);
        updateFontSurf = true;
        updatePreview = true;
        
        // message
        uiMsgTime = room_speed;
        uiMsg = "마스크를 붙여넣었읍니다.";
    }
}


/*
    HIGHLIGHT / MODAL BG
    ============
*/
if (uiModal)
{
    uiActive = true;
    // iui_end();
    // iui_begin();
    
    var _winModalW = 800, _winModalH = 600;
    var _winModalX = _winhalfw - (_winModalW >> 1), _winModalY = _winhalfh - (_winModalH >> 1);
    draw_sprite_tiled(spr_bgtexture, 0, 0, 0);
    
    // draw message & backdrop
    if (uiModalInfo)
    {
        iui_rect(_winModalX + 10, _winModalY + 10, _winModalW, _winModalH, c_black);
        iui_rect(_winModalX, _winModalY, _winModalW, _winModalH, COL.BASE);
    
        iui_align_center();
        var _modalInfo = "<ESC> 단추로 나가기";
        var _modalBlink = merge_colour(COL.TEAL, COL.HIGHLIGHT2, (iuiAnimTime >> 3) & 1);
        iui_label_transform(_winhalfw, WIN_HEI - 50 + 2, _modalInfo, 2, 2, 0, c_black, 1);
        iui_label_transform(_winhalfw, WIN_HEI - 50, _modalInfo, 2, 2, 0, _modalBlink, 1);
        iui_align_pop();
    }
    
    // draw highlight content
    switch (uiModalState)
    {
        default:
        case UI_MODAL.PREVIEW:
            uiModalInfo = true;
            var _modalTitleY = _winModalY + 21;
            var _modalTitleH = 42;
            
            // title
            iui_rect(_winModalX, _winModalY, _winModalW, _modalTitleH, COL.WHITE);
            iui_align_center();
            iui_label(_winhalfw, _modalTitleY, uiModalMsg, COL.BASE);
            iui_align_pop();
            
            // Content
            iuiButtonShadow = false;
            var _inputX = _winModalX + _bigmargin;
            var _inputTestY = _modalTitleY + _bigmargin + 32;
            var _inputFontY = _modalTitleY + _bigmargin + (_winModalH >> 1);
            var _inputW = _winModalW - _bigmargin * 2;
            var _inputH = (_winModalH >> 1) - _bigmargin * 2;
            
            var btnTestInput = ui_button_icon(_inputX, _inputTestY, _inputW, _inputH, "글꼴 시험 영역...#================#아무 글자나 입력해보시오###BTN_TESTINPUT", -1, c_white);
            var btnFontInput = ui_button_icon(_inputX, _inputFontY, _inputW, _inputH, "불러온 원본 글꼴 시험 영역...#================#아무 글자나 입력해보시오###BTN_FONTINPUT", -1, c_white);
            iuiButtonShadow = true;
            
            // Hide button
            var _testbg = COL.BASE, _teststr = COL.WHITE;
            var _fontbg = COL.BASE, _fontstr = COL.WHITE;
            if (uTestInputActive)
                _teststr = COL.PISS;
            if (uFontInputActive)
                _fontstr = COL.PISS;
            
            iui_label(_inputX, _inputTestY - _smallmargin, "현재 글꼴 :", COL.PISS);
            iui_rect(_inputX - 2, _inputTestY - 2, _inputW + 4, _inputH + 4, COL.WHITE);
            iui_rect(_inputX, _inputTestY, _inputW, _inputH, _testbg);
            
            iui_label(_inputX, _inputFontY - _smallmargin, "원본 .TTF 글꼴 :", COL.PISS);
            iui_rect(_inputX - 2, _inputFontY - 2, _inputW + 4, _inputH + 4, COL.WHITE);
            iui_rect(_inputX, _inputFontY, _inputW, _inputH, _fontbg);
            
            if (btnTestInput)
            {
                uTestInputActive = true;
                uFontInputActive = false;
            }
            else if (btnFontInput)
            {
                uTestInputActive = false;
                uFontInputActive = true;
            }
            else if (mouse_check_button_pressed(mb_left) && iui_hotItem == -1)
            {
                uTestInputActive = false;
                uFontInputActive = false;
                kia_type = "";
            }
            
            // Draw strings & cursor
            var _testtext = uTestInput;
            if (uTestInputActive)
            {
                if (uInputKor)
                    _testtext += "[" + kia_type + "]";
                else if ((iuiAnimTime >> 3) & 1)
                    _testtext += "_";
            }
            
            var _fonttext = uFontInput;
            if (uFontInputActive)
            {
                if (uInputKor)
                    _fonttext += "[" + kia_type + "]";
                else if ((iuiAnimTime >> 3) & 1)
                    _fonttext += "_";
            }
            
            //////////////////
            if (FNT_DKB)
            {
                var _asciifnt = sprEngSlantSheet;
                
                if (FNT_ASCII)
                    _asciifnt = fntAsciiSprite;
                
                hj_draw_sheet(fntSprite, _asciifnt, _inputX + 10, _inputTestY + 10, _testtext, _teststr, 1);
            }
            else
            {
                var _asciifnt = sprYayoC64;
                
                if (FNT_ASCII)
                    _asciifnt = -1;
                
                hj_draw_comp(fntSprite, _asciifnt, _inputX + 10, _inputTestY + 10, _testtext, _teststr, 1);
            }
            
            draw_set_font(fntCurrent);
            iui_label(_inputX + 10, _inputFontY + 10, _fonttext, _fontstr);
            draw_set_font(fntOWO);
            
            // draw_sprite(fntAsciiSprite, 0, WIN_WID / 2, WIN_HEI / 2);
            // draw_sprite(fntSprite, 0, 10, 10);
            // hj_draw(_inputX + 10, _inputFontY + 10, _fonttext, _fontstr, 1);
            // iui_label(_inputX + 10, _inputTestY + 10, _testtext, _teststr);
            break;
        
        case UI_MODAL.EXPORT:
            uiModalInfo = true;
            var _modalTitleY = _winModalY + 21;
            var _modalTitleH = 42;
            
            // title
            iui_rect(_winModalX, _winModalY, _winModalW, _modalTitleH, COL.WHITE);
            iui_align_center();
            iui_label(_winhalfw, _modalTitleY, uiModalMsg, COL.BASE);
            iui_align_pop();
        
            // show image preview
            var _surfY = (_winModalH >> 1) - (_bigmargin >> 1);
            if (FNT_DKB) // dkb844
            {
                var _surfWid = (_winModalW >> 1) - _smallmargin;
                var _surfHeiHan = (_surfWid / surface_get_width(previewTex)) * surface_get_height(previewTex);
                var _surfHeiAscii = (_surfWid / surface_get_width(previewAsciiTex)) * surface_get_height(previewAsciiTex);
                
                draw_surface_stretched(previewTex, _winhalfw - _surfWid - _smallmargin * 0.5, _modalTitleY + _bigmargin, _surfWid, _surfHeiHan);
                draw_surface_stretched(previewAsciiTex, _winhalfw + _smallmargin * 0.5, _modalTitleY + _bigmargin, _surfWid, _surfHeiAscii);
            }
            else // non-dbk844 (compat.)
            {
                var _surfWid = _winModalW - (_bigmargin << 1);
                var _surfHei = (_surfWid / surface_get_width(previewTex)) * surface_get_height(previewTex);
                
                var _surfHei2 = (_winModalH >> 1) - (_bigmargin >> 1);
                var _surfWid2 = (_surfHei2 / surface_get_height(previewTex)) * surface_get_width(previewTex);
                
                if (_surfHei >= (_winModalH >> 1))
                {
                    _surfWid = _surfWid2;
                    _surfHei = _surfHei2;
                }
                
                draw_surface_stretched(previewTex, _winhalfw - (_surfWid >> 1), _modalTitleY + _bigmargin, _surfWid, _surfHei);
            }
            
            iui_align_center();
            iui_label(_winhalfw, _modalTitleY + _surfY + _bigmargin + _smallmargin, "(그림 크기 조절로 픽셀이 뭉개져 보일수 있으나 결과물에 영향은 없습니다.)", COL.PISS);
            iui_align_pop();
            
            // show attributes
            var _attribY = _modalTitleY + _bigmargin * 2 + _surfY;
            var _buttonmargin = 128;
            var btnExport = ui_button(_winhalfw - _buttonmargin - 75, _attribY + 150, 150, 42, ".PNG 내보내기!");
            var btnExportHeader = ui_button(_winhalfw + _buttonmargin, _attribY + 150, 150, 42, "헤더 파일 내보내기!");
            // var btnReload = ui_button(_winhalfw + 80, _attribY + 150, 150, 42, "미리보기");
            
            iui_align_push(1, 1);
            iui_label(_winhalfw, _attribY + 10, "한글 이미지 수 : " + string(gridWid * gridHei), COL.WHITE);
            iui_label(_winhalfw, _attribY + 40, "한글 격자 크기 : [" + string(charWid) + ", " + string(charWid) + "]", COL.WHITE);
            
            if (FNT_DKB)
            {
                iui_label(_winhalfw, _attribY + 70, "도깨비한글 8x4x4벌식 (hj_draw_*)", COL.HIGHLIGHT);
                iui_label(_winhalfw, _attribY + 100, "격자 : 총 [" + string(gridWid) + ", " + string(gridHei) + "]칸", COL.WHITE);
                if (FNT_ASCII)
                    iui_label(_winhalfw, _attribY + 130, "ASCII 격자 크기 : [" + string(charAsciiWid) + ", " + string(charAsciiHei) + "] * 256 이미지", COL.WHITE);
            }
            else
            {
                iui_label(_winhalfw, _attribY + 70, "일반 / 이전버전 (hj_draw_comp_*)", COL.HIGHLIGHT);
                
                var _str = "중성 모양에 따른 벌 사용 (global.hjCompSpecialMiddle) : ";
                if (FNT_MIDDLE)
                    _str += "true";
                else
                    _str += "false";
                iui_label(_winhalfw, _attribY + 100, _str, COL.PISS);
                
                _str = "받침 여부에 따른 벌 사용 (global.hjCompSpecialLast) : ";
                if (FNT_LAST)
                    _str += "true";
                else
                    _str += "false";
                iui_label(_winhalfw, _attribY + 130, _str, COL.PISS);
            }
            iui_align_pop();
            /*
            iui_align_push(2, 0);
            var _checkX = _winhalfw - 80 - 16;
            iui_label(_checkX, _attribY, "격자 내보내기 : ", COL.WHITE);
            var _exportgrid = ui_checkbox(_checkX, _attribY, 16, 16, cbExportGrid, "CB_EXPORT_GRID");
            
            var _checkX = _winhalfw + 80 + string_width("배경 내보내기 : ");
            iui_label(_checkX, _attribY, "배경 내보내기 : ", COL.WHITE);
            var _exportbg = ui_checkbox(_checkX, _attribY, 16, 16, cbExportBG, "CB_EXPORT_BG");
            iui_align_pop();
            
            if (_exportbg != cbExportBG || _exportgrid != cbExportGrid)
            {
                cbExportBG = _exportbg;
                cbExportGrid = _exportgrid;
                
                build_font_tex_ext(cbExportGrid, c_black, cbExportBG);
                surface_resize(previewTex, surface_get_width(fntTex), surface_get_height(fntTex));
                surface_resize(previewAsciiTex, surface_get_width(fntAsciiTex), surface_get_height(fntAsciiTex));
                surface_copy(previewTex, 0, 0, fntTex);
                surface_copy(previewAsciiTex, 0, 0, fntAsciiTex);
                build_font_tex();
            }
            */
            
            if (btnExport)
            {
                if (FNT_DKB)
                {
                    var _path = get_save_filename_ext("PNG 폰트 이미지|*.png", "font" + string(charWid) + "x" + string(charWid) + "_han", fntPath, "한글 폰트 저장 (도깨비한글)");
                    
                    if (_path != "")
                    {
                        surface_save(previewTex, _path);
                        
                        if (FNT_ASCII)
                        {
                            _path = get_save_filename_ext("PNG 폰트 이미지|*.png", "font" + string(charWid) + "x" + string(charWid) + "_ascii", _path, "ASCII 폰트 저장 (도깨비한글)");
                            
                            if (_path != "")
                                surface_save(previewAsciiTex, _path);
                        }
                    }
                }
                else
                {
                    var _path = get_save_filename_ext("PNG 폰트 이미지|*.png", "font" + string(charWid) + "x" + string(charWid), fntPath, "폰트 저장");
                    
                    if (_path != "")
                    {
                        // export!
                        surface_save(previewTex, _path);
                    }
                }
            }
            else if (btnExportHeader)
            {
                // Go to export
                // var _path = get_save_filename_ext(".h 헤더 파일|*.h", "font" + string(charWid) + "x" + string(charWid) + ".h", fntPath, "헤더 파일 저장");
                uiModal = true;
                uiModalMsg = "헤더로 내보내기";
                uiModalState = UI_MODAL.EXPORT_HEADER;
            }
            break;
            
        case UI_MODAL.EXPORT_HEADER:
            uiModalInfo = false;
        
            // background & title
            var _modalwid = WIN_WID * 0.5, _modalhei = WIN_HEI * 0.5;
            var _modalhalfwid = _modalwid * 0.5, _modalhalfhei = _modalhei * 0.5;
            var _modalx = _winhalfw - _modalhalfwid, _modaly = _winhalfh - _modalhalfhei;
            iui_rect(_modalx + 10, _modaly + 10, _modalwid, _modalhei, c_black);
            iui_rect(_modalx, _modaly, _modalwid, _modalhei, COL.BASE);
            
            var _modalTitleY = _modaly + 21;
            var _modalTitleH = 42;
            
            iui_rect(_modalx, _modaly, _modalwid, _modalTitleH, COL.WHITE);
            iui_align_center();
            iui_label(_winhalfw, _modalTitleY, uiModalMsg, COL.BASE);
            iui_align_pop();
            
            // UI
            var _itemx = _modalx + _modalhalfwid;
            var _itemy = _modalTitleY + 64;
            iui_align_center();
            iui_label(_itemx, _itemy, "주의 : 헤더 파일로 내보내면 폰트 그래픽의 알파값은 버려지게 되고,#각 픽셀당 흑백 1비트, uint8로 인코딩 된 비트맵 배열로 내보내집니다!", uTextCol);
            
            _itemy += 128;
            iui_align_push(2, 0);
            iui_label(_itemx, _itemy, "코멘트 생성 : ", uTextCol);
            cbExportHeaderGenComments = ui_checkbox(_itemx + 2, _itemy, 16, 16, cbExportHeaderGenComments, "GEN_COMMENTS");
            
            _itemy += 32;
            iui_label(_itemx, _itemy, "(한국어 폰트만) 빈 칸 제외하기 : ", uTextCol);
            cbExportHeaderTrimBlanks = ui_checkbox(_itemx + 2, _itemy, 16, 16, cbExportHeaderTrimBlanks, "TRIM_BLANKS");
            
            var btnExport = ui_button(_winhalfw - 75, _modaly + _modalhei - 64, 150, 42, "내보내기!");
            iui_align_pop();
            
            
            iui_align_pop();
            
            if (btnExport)
            {
                var _path = get_save_filename_ext(".h 헤더 파일|*.h", "font" + string(charWid) + "x" + string(charWid) + ".h", fntPath, "헤더 파일 저장");
                
                if (_path != "")
                {
                    exportHeaderRequest = true;
                    exportHeaderPath = _path;
                    
                    uiModalState = UI_MODAL.MESSAGE;
                    uiModalMsg = "저장 중...";
                }
                else
                {
                    uiMsgTime = room_speed;
                    uiMsg = "저장하는데 문제가 있었읍니다 : 경로가 잘못되었읍니다.";
                }
            }
            
            break;
        
        case UI_MODAL.DEBUG:
            uiModalInfo = false;
            var _atlaswid = WIN_WID * 0.5 - 20;
            var _bakedx = _winhalfw - 10 - _atlaswid;
            var _maskx = _winhalfw + 10;
            var _debugy = 250;
            
            var _atlashei = (_atlaswid / sprite_get_width(bakedAtlas)) * sprite_get_height(bakedAtlas);
            iui_label_shadow(_bakedx, _debugy, "BAKED :", c_yellow, 0, 1, c_black);
            iui_rect(_bakedx, _debugy + 20, _atlaswid, _atlashei, $FF00FF);
            draw_sprite_stretched(bakedAtlas, 0, _bakedx, _debugy + 20, _atlaswid, _atlashei);
            
            _atlashei = (_atlaswid / sprite_get_width(maskAtlas)) * sprite_get_height(maskAtlas);
            iui_label_shadow(_maskx, _debugy, "MASK :", c_yellow, 0, 1, c_black);
            iui_rect(_maskx, _debugy + 20, _atlaswid, _atlashei, $FF00FF);
            draw_sprite_stretched(maskAtlas, 0, _maskx, _debugy + 20, _atlaswid, _atlashei);
            
            draw_surface(maskTemp, _maskx, WIN_HEI - 100);
            break;
            
        case UI_MODAL.LOADING:
            iui_align_center();
            var _statusstr = "불러오는 중...";
            var _statuswid = string_width(_statusstr) * 3 + _bigmargin;
            var _statushei = string_height(_statusstr) * 3 + _bigmargin;
            
            iui_rect(_winhalfw - (_statuswid >> 1) - 2, _winhalfh - (_statushei >> 1) - 2, _statuswid + 4, _statushei + 4, c_black);
            iui_rect(_winhalfw - (_statuswid >> 1) + 10, _winhalfh - (_statushei >> 1) + 10, _statuswid, _statushei, c_black);
            iui_rect(_winhalfw - (_statuswid >> 1), _winhalfh - (_statushei >> 1), _statuswid, _statushei, COL.PISS);
            // iui_label_transform(_winhalfw, _winhalfh + 6, _statusstr, 3, 3, 0, c_black, 1);
            iui_label_transform(_winhalfw, _winhalfh, _statusstr, 3, 3, 0, c_black, 1);
            iui_align_pop();
            break;
            
        case UI_MODAL.MESSAGE:
            iui_align_center();
            var _statusstr = uiModalMsg;
            var _statuswid = string_width(_statusstr) * 1 + _bigmargin;
            var _statushei = string_height(_statusstr) * 1 + _bigmargin;
            
            iui_rect(_winhalfw - (_statuswid >> 1) - 2, _winhalfh - (_statushei >> 1) - 2, _statuswid + 4, _statushei + 4, c_black);
            iui_rect(_winhalfw - (_statuswid >> 1) + 10, _winhalfh - (_statushei >> 1) + 10, _statuswid, _statushei, c_black);
            iui_rect(_winhalfw - (_statuswid >> 1), _winhalfh - (_statushei >> 1), _statuswid, _statushei, COL.WHITE);
            // iui_label_transform(_winhalfw, _winhalfh + 6, _statusstr, 3, 3, 0, c_black, 1);
            iui_label_transform(_winhalfw, _winhalfh, _statusstr, 1, 1, 0, c_black, 1);
            iui_align_pop();
            break;
    }
}

iui_end();


// Message
if (uiMsgTime > 0)
{
    uiMsgTime--;
    
    var _boxw = string_width(uiMsg) * 2 + _smallmargin;
    var _boxh = string_height(uiMsg) * 2 + _smallmargin;
    var _boxx = _winhalfw - (_boxw >> 1);
    var _boxy = WIN_HEI - _bigmargin * 2 - (_boxh >> 1);
    
    iui_rect(_boxx - 2, _boxy - 2, _boxw + 4, _boxh + 4, c_black);
    iui_rect(_boxx + 5, _boxy + 5, _boxw, _boxh, c_black);
    iui_rect(_boxx, _boxy, _boxw, _boxh, COL.PISS);
    
    iui_align_center();
    iui_label(_winhalfw, _boxy + (_boxh >> 1), uiMsg, c_black);
    iui_align_pop();
}

// oh wtf
if (PEPPIS)
{
    var _maxx = max(window_mouse_get_x(), PEP_X), _minx = min(window_mouse_get_x(), PEP_X);
    var _maxy = max(window_mouse_get_y(), PEP_Y), _miny = min(window_mouse_get_y(), PEP_Y);
    var _dx = _maxx - _minx, _dy = _maxy - _miny;
    
    draw_rectangle_colour(_minx, _miny, _maxx, _maxy, COL.HIGHLIGHT, COL.HIGHLIGHT, COL.HIGHLIGHT, COL.HIGHLIGHT, true);
    
    draw_set_valign(fa_bottom);
    iui_label(_minx, _miny, "[" + string(_minx / WIN_WID) + ", " + string(_miny / WIN_HEI) + "]#[" + string(_minx) + "px, " + string(_miny) + "px]", COL.PISS);
    
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    iui_label(_minx + (_dx >> 1), _miny + (_dy >> 1), "[" + string(_dx / WIN_WID) + ", " + string(_dx / WIN_HEI) + "]#[" + string(_dx) + "px, " + string(_dx) + "px]", COL.PISS);
    
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    iui_label(_maxx, _maxy, "[" + string(_maxx / WIN_WID) + ", " + string(_maxy / WIN_HEI) + "]#[" + string(_maxx) + "px, " + string(_maxy) + "px]", COL.PISS);
}

#section tooltip and cursor
// Tooltip
if (uiTooltipShow)
{
    var _labelwid = string_width(uiTooltipMsg) + 20;
    var _labelhei = string_height(uiTooltipMsg) + 20;
    
    iui_align_center();
    iui_rect(iui_inputX + 10, iui_inputY + 10, _labelwid, _labelhei, c_black); // shadow
    iui_rect(iui_inputX - 1, iui_inputY - 1, _labelwid + 2, _labelhei + 2, c_black);
    iui_rect(iui_inputX, iui_inputY, _labelwid, _labelhei, COL.PISS);
    iui_label(iui_inputX + (_labelwid >> 1), iui_inputY + (_labelhei >> 1), uiTooltipMsg, c_black);
    iui_align_pop();
}

// Cursor logic
if (uiCursorInCrop)
{
    if (cropmode == 1)
        uiCursor = 1;
    else if (cropmode == 2)
        uiCursor = 2;
    else
        uiCursor = 3;
}
else
{
    uiCursor = 0;
}
draw_sprite(spr_mouse, uiCursor, iui_inputX, iui_inputY);